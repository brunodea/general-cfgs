T 1459564688 18<ontop18>	THen I started using Consolas/Inconsolata/Droid Sans Mono
T 1459564691 18<ontop18>	Never left there.
T 1459564779 18<panicbit18>	http://i.imgur.com/pzsoGaY.png
T 1459564798 18<curtism18>	heh I like it
T 1459564802 18<panicbit18>	Monofur ;)
T 1459564815 18<curtism18>	I have a thing for quirky fonts
T 1459564822 18<curtism18>	Actually I think I've tried Monofur
T 1459564845 18<panicbit18>	curtism: The weird thing is that I got so used to it that I can barely differentiate between monofur and dejavu anymore...
T 1459564890 18<curtism18>	Before my current font (Pointfree), I used ProFont for a long time
T 1459564894 18<curtism18>	That font is sick, yo
T 1459564896 18<aatch18>	panicbit, the upper case letters look ok, not a fan of the lowercase ones though.
T 1459564971 18<curtism18>	Pointfree looks great in caps
T 1459564988 18<panicbit18>	I'd like to try a font with ligatures for certain programming symbols, but none of my prefered editors support ligatures :D
T 1459564989 18<ontop18>	curtism: Was that Screenshot pointfree?
T 1459565000 18<curtism18>	Yeah
T 1459565008 18<LambdaComplex18>	panicbit: that is, without a doubt, the second-worst font i've ever seen used in a terminal
T 1459565018 18<curtism18>	Hm, I don't like the sizing/proportion of Monofur
T 1459565025 18<panicbit18>	LambdaComplex: It's not a terminal screeny :)
T 1459565032 18<panicbit18>	LambdaComplex: Though, I also use it in the terminal ;D
T 1459565036 18<LambdaComplex18>	okay, text editor
T 1459565047 18<LambdaComplex18>	actually it _might_ be third-worst
T 1459565054 18<LambdaComplex18>	can't decide if it's worse than terminus or not
T 1459565069 18<curtism18>	This used to be my thing (ProFont) https://u.cmcenroe.me/e1dee3a.png
T 1459565075 18<LambdaComplex18>	also >not using one true bracket style
T 1459565084 18<LambdaComplex18>	ooh, gruvbox?
T 1459565085 18<panicbit18>	curtism: Hm, looks interesting
T 1459565092 18<panicbit18>	curtism: But it looks a bit dense to me
T 1459565103 18<panicbit18>	curtism: But that may be the editor/terminal
T 1459565112 18<curtism18>	It's quite a thick font
T 1459565122 18*	LambdaComplex should try gruvbox sometime
T 1459565144 18<LambdaComplex18>	also deja vu sans mono for life
T 1459565156 18<panicbit18>	^
T 1459565169 18<curtism18>	On Linux I agree with you
T 1459565171 18<panicbit18>	It's my default font, together with monofur
T 1459565183 18<curtism18>	It's the only set of fonts that consistently render nicely at any size
T 1459565184 18<panicbit18>	LambdaComplex: You should check out Hack though, it's based on DejaVu
T 1459565194 18<panicbit18>	LambdaComplex: http://sourcefoundry.org/hack/
T 1459565251 18<curtism18>	But one of my criteria for a programming font is that it doesn't include bold or italic versions
T 1459565284 18<panicbit18>	In the end it's all personal choice
T 1459565293 18<panicbit18>	There's no "the best" font
T 1459565301 18<panicbit18>	There's "the worst" font though :P
T 1459565335 18<LambdaComplex18>	panicbit: it's literally exactly the same with the exception of like 4 glyphs
T 1459565336 18<Xion18>	Since we're showing off: http://i.imgur.com/VrMbX0u.png (DejaVu Sans Mono)
T 1459565361 18<panicbit18>	LambdaComplex: Doesn't look like that to me
T 1459565366 18<panicbit18>	LambdaComplex: But it's ok
T 1459565386 18<curtism18>	Xion: psh
T 1459565453 18<Xion18>	curtism: No, I use zsh :)
T 1459565463 18<curtism18>	har
T 1459565493 18<LambdaComplex18>	panicbit: red square = hack http://i.imgur.com/8SqL6mT.gif
T 1459565546 18<panicbit18>	LambdaComplex: YOU WIN
T 1459565546 18<curtism18>	You're a hack!
T 1459565569 18<LambdaComplex18>	>implying i don't know my fonts
T 1459565571 18<LambdaComplex18>	pfft
T 1459565578 18<LambdaComplex18>	also https://u.teknik.io/esVSw.png
T 1459565580 18<panicbit18>	LambdaComplex: 0 has also a different glyph though
T 1459565581 18<LambdaComplex18>	since we're showing off
T 1459565620 18<panicbit18>	LambdaComplex: herbstluftwm?
T 1459565620 18<Xion18>	what is this ugly python lol
T 1459565636 18<LambdaComplex18>	panicbit: nope, good guess though
T 1459565643 18<panicbit18>	LambdaComplex: Well, it's a lazy guess
T 1459565647 18<LambdaComplex18>	bspwm
T 1459565663 18<LambdaComplex18>	(which iirc was originally "hlwm with less features")
T 1459565761 18<LambdaComplex18>	panicbit: so everything I've seen using XCB in C has the connection as a global thing. should i avoid that in rust?
T 1459565776 18<panicbit18>	LambdaComplex: If you can yes
T 1459565808 18<panicbit18>	LambdaComplex: But since the Connection doesn't require &mut self in it's methods it should be fine to use it in a global variable
T 1459565815 18<panicbit18>	LambdaComplex: e.g. using lazy_static!
T 1459565912 18<LambdaComplex18>	panicbit: so what exactly does lazy_static! do?
T 1459566004 18<curtism18>	magic
T 1459566047 18<LambdaComplex18>	what kind of magic?
T 1459566062 18<aatch18>	LambdaComplex, the simple answer is that it creates a lazily-intialized global variable.
T 1459566141 18<panicbit18>	LambdaComplex: Usually you can only initialize a global variable using static initializers
T 1459566167 18<panicbit18>	LambdaComplex: But using some trickery lazy_static! allows you to use arbitrary functions to initilize them
T 1459566348 18<panicbit18>	LambdaComplex: The initialization will start as soon as you try to access the static
T 1459566484 18<LambdaComplex18>	panicbit: So how exactly do I use it to get the connection?
T 1459566493 18<LambdaComplex18>	(since connect() returns a Result now)
T 1459566529 18<panicbit18>	LambdaComplex: You probably should handle that inside of the lazy_static initialization
T 1459566548 18<panicbit18>	LambdaComplex: Otherwise you'd be required to always go through the Result when you try to access the static
T 1459566548 18*	LambdaComplex will try that
T 1459566585 18<panicbit18>	Since a connection error is fatal this should work out well enough
T 1459566597 18<panicbit18>	You can handle it the same way as you did before
T 1459566617 18<LambdaComplex18>	panicbit: That's how I'm trying it and it's not working :(
T 1459566626 18<panicbit18>	LambdaComplex: Code and errors!
T 1459566631 18<panicbit18>	LambdaComplex: ;P
T 1459566651 18<panicbit18>	There's not much I can't do without them :)
T 1459566660 18<panicbit18>	can*
T 1459566662 18<panicbit18>	xD
T 1459566679 18<LambdaComplex18>	Hold on, lemme push to github
T 1459566685 18<panicbit18>	sure
T 1459566836 18<LambdaComplex18>	panicbit: https://github.com/sector-f/swm-rust/blob/master/src/swm.rs
T 1459566874 18<panicbit18>	LambdaComplex: And the error?
T 1459566885 18<panicbit18>	Eh, let me pull it
T 1459566940 18<panicbit18>	Eh, that sucks...
T 1459566988 18<panicbit18>	LambdaComplex: Try wrapping it in an Arc
T 1459567061 18<panicbit18>	LambdaComplex: Nope, that won't work
T 1459567074 18<panicbit18>	Since the type isn't even Send
T 1459567087 18<panicbit18>	You could hack around that
T 1459567095 18<panicbit18>	But it's not worth the trouble
T 1459567107 18<panicbit18>	It's easier not to use statics...
T 1459567240 18<panicbit18>	Not to mention that hacking around it is unsafe
T 1459567264 18<panicbit18>	Since you could potentially use it from different threads, which is very likely not supported
T 1459567414 18<LambdaComplex18>	panicbit: ...Should I just stop trying to make it global?
T 1459567421 18<panicbit18>	LambdaComplex: Yes..
T 1459567432 18<LambdaComplex18>	panicbit: That I can handle :D
T 1459567436 18<panicbit18>	:D
T 1459567858 18<LambdaComplex18>	Damn Rust and its memory safety
T 1459567864 18<LambdaComplex18>	What if I _want_ memory errors!?
T 1459567873 18<curtism18>	unsafe { }
T 1459568137 19*	Now talking on 22#rust-beginners
T 1459568137 22*	Topic for 22#rust-beginners is: Beginner's Rust discussion, unlogged. Ask away! |  Playground  https://play.rust-lang.org | Forum  https://users.rust-lang.org | Conduct   https://www.rust-lang.org/conduct.html 
T 1459568137 22*	Topic for 22#rust-beginners set by 26steveklabnik!root@moz-fft.uo8.55.45.IP (24Wed Feb 17 21:12:56 2016)
T 1459903415 19*	Now talking on 22#rust-beginners
T 1459903415 22*	Topic for 22#rust-beginners is: Beginner's Rust discussion, unlogged. Ask away! |  Playground  https://play.rust-lang.org | Forum  https://users.rust-lang.org | Conduct   https://www.rust-lang.org/conduct.html 
T 1459903415 22*	Topic for 22#rust-beginners set by 26steveklabnik!root@moz-fft.uo8.55.45.IP (24Wed Feb 17 21:12:56 2016)
T 1459905901 18<chasinglogic18>	Does anyone here have any experience with Diesel?
T 1459906415 18<caconym18>	are there any books better than the rust-lang.org one and "rust by example" for rust beginners with a fair amount of experience with other languages? so far "rust by example" seems like the best option
T 1459906444 18<caconym18>	i suppose by "books" i mean "websites"
T 1459907042 18<curtism18>	caconym: How do you mean "better"? What are you looking for?
T 1459907428 18<caconym18>	curtism: guides that help me to quickly gain insight into rust's features and get to a point where i can use it comfortably?
T 1459907495 18<aatch18>	caconym, beyond the book and rust-by-example, not much right now.
T 1459907501 18<caconym18>	i don't mean to imply that the aforementioned books are bad, i'm just wondering if i missed any
T 1459907508 18<caconym18>	aatch: thanks
T 1459907653 18<caconym18>	i started with "the book" and felt like a lot of interesting things were glossed over e.g. ok, this is the syntax for explicit lifetime annotations, but when would I want to use them?
T 1459907742 18<ivan18>	https://doc.rust-lang.org/nomicon/ covers a lot of interesting stuff
T 1459907903 18<caconym18>	ivan: i'll check that out, thanks
T 1459908125 18<aatch18>	caconym, what languages do you have experience with, btw?
T 1459908168 18<aatch18>	caconym, since it'll probably be worthwhile to focus on certain aspects of the language over others depending on what you're used to.
T 1459908186 18<llandersll18>	I'm writing a wrapper for a C api. This API passes around 32-bit unsigned integers as ID values, and uses a value of -1 as "invalid ID" which is used several places. Obviously Rust doesn't like a u32 with value -1, am I right in thinking that's equivalent to u32::MAX?
T 1459908234 18<aatch18>	llandersll, it is, but I prefer using !0
T 1459908257 18<aatch18>	llandersll, I think it makes it more clear that it's a special value that way too.
T 1459908281 18<llandersll18>	yeah I like that, thanks!
T 1459908375 18<aatch18>	llandersll, assuming you have a wrapper ID type, having an `is_invalid` method and maybe a `INVALID_ID` constant around isn't a bad idea either.
T 1459908460 18<llandersll18>	Yeah there's a #define on the C side for that too so that would make sense
T 1459908549 18<aatch18>	llandersll, it's a self-documenting code thing.
T 1459908593 18<caconym18>	aatch: haskell, C, ruby primarily
T 1459908623 18<caconym18>	i have to run actually but i will grep for your name in the logs later if you happen to have any useful info based on that :) thx for the resource suggestion
T 1459908649 18<aatch18>	caconym, how much C? Because if it's not much, then I think "Ownership" is probably the best thing to look at.
T 1459911157 18<caconym18>	aatch: a fair amount, i'm not a crazy C hacker but i have a good-enough feel for pointers and memory management and such
T 1459911203 18<caconym18>	the ownership/lifetime stuff is what intrigues me about rust the most, i've been trying to to grok it in the context of memory management in C actually
T 1459911260 18<caconym18>	i think i'm getting a feel for it now but in the beginning especially with some of the automatic dereferencing that goes on i was a bit confused
T 1459911294 18<aatch18>	caconym, well ownership can be mostly easily thought of as "who frees this memory?".
T 1459911346 18<aatch18>	caconym, which isn't an alien concept in C where you have APIs that "take ownership" of a supplied pointer.
T 1459911399 18<caconym18>	yup, the biggest head scratchers have come when i wanted to pass off a pointer/reference but the lifetime system forbade me from doing it
T 1459911448 18<aatch18>	caconym, so borrowing/lifetimes are all about ensuring that your pointer is valid.
T 1459911472 18<aatch18>	caconym, well, lifetimes are, borrowing is so you don't have to always copy data.
T 1459911572 18<aatch18>	caconym, I find it easiest to build it up from the basic ideas. You start with memory management: an allocated pointer must be freed exactly once. Which you can solve using ownership.
T 1459911630 18<aatch18>	caconym, then you want to have pointers that *don't* own the data they point to, since otherwise you need to copy data. A LOT. That's where borrowed pointers come in.
T 1459911679 18<aatch18>	caconym, then finally you want to make sure that the borrowed pointers can't be used after the original pointer has been freed. That's lifetimes.
T 1459911694 18<caconym18>	well "borrowed" references seem analagous to pointers in C, right? with the static guarantee based on lifetimes that you can't have a pointer to memory that's been freed
T 1459911734 18<aatch18>	caconym, well they're just pointers at runtime.
T 1459911749 18<caconym18>	i think the thing i haven't grokked yet is how to do the C pattern where you allocate some memory on the heap and return a reference to it
T 1459911756 18<aatch18>	caconym, Box
T 1459911758 18<caconym18>	or what the equivalent of that would be
T 1459911760 18<caconym18>	yeah, ok
T 1459911771 18<caconym18>	i glanced at that documentation :)
T 1459911777 18<caconym18>	sounds like i should take another look
T 1459911889 18<caconym18>	i had a feeling it was some lifetimes magic ala crazy typesystem extensions in Haskell, i'm kinda glad that's not the case
T 1459911904 18<caconym18>	trying to take a break from that sort of tomfoolery
T 1459911922 18<aatch18>	caconym, it might help if you don't try to think in terms of C pointers directly.
T 1459911963 18<aatch18>	caconym, because while C has one(-ish) pointer type, Rust has 3 (main) pointer types.
T 1459911992 18<aatch18>	caconym, Actually, it's more like 5.
T 1459912040 18<caconym18>	is &mut one of them?
T 1459912058 18<aatch18>	caconym, it's fairly common for people to confuse themselves because they don't realise that *this* specific use of foo_t* is equivalent to Box<Foo>, not &Foo.
T 1459912071 18<aatch18>	caconym, it is.
T 1459912079 18<caconym18>	ah, is that the Deref trait magic?
T 1459912091 18<aatch18>	caconym, not sure what you mean.
T 1459912110 18<caconym18>	'*this* specific use of foo_t* is equivalent to Box<Foo>, not &Foo.'
T 1459912127 18<aatch18>	caconym, I'm talking about converting C code/patterns into Rust.
T 1459912134 18<caconym18>	like, dereferencing behavior of a type being defined by its implementation of that trait
T 1459912137 18<caconym18>	oh, ok
T 1459912160 18<aatch18>	caconym, like returning a heap-allocated pointer.
T 1459934845 19*	Now talking on 22#rust-beginners
T 1459934845 22*	Topic for 22#rust-beginners is: Beginner's Rust discussion, unlogged. Ask away! |  Playground  https://play.rust-lang.org | Forum  https://users.rust-lang.org | Conduct   https://www.rust-lang.org/conduct.html 
T 1459934845 22*	Topic for 22#rust-beginners set by 26steveklabnik!root@moz-fft.uo8.55.45.IP (24Wed Feb 17 21:12:56 2016)
T 1459939299 18<LambdaComplex18>	panicbit: Is that 0.006 with or without optimization?
T 1459944270 18<leaper18>	Hi, what's up with rustup failing to download "nightly" when I run "rustup update nightly" (or specifying any triple)? I get an error: error: manifest missing package for component rust-std-aarch64-unknown-linux-gnu
T 1459944307 18<leaper18>	Stable downloads OK.
T 1459944334 18<leaper18>	You'd think a broken nightly would be fixed overnight. :-)
T 1459944553 18<kefin_18>	is there an into/from-like trait for strings to copy types (like i32, f64)?
T 1459945060 18<kefin_18>	I'm getting 'the impl doesn't reference any types defined in this crate', is there anything other than struct MyType(OriginalType); to solve this?
T 1459945302 18<jaysonsantos18>	Hey guys, I have a vector wrapped by an Arc and I try to get it inside a thread with clone and it works ok, but when I initialize the thread inside a block like for it won't allow me get the data because of the moved binding, is there anyway to make it work? http://is.gd/Q6DbWQ
T 1459945347 18<kefin_18>	jaysonsantos: I think you need an Arc to a Mutex to a Vector: Arc<Mutex<Vec<...>>>
T 1459945377 18<jaysonsantos18>	kefin_: But that would block the other threads to read the data until the first to acquire the lock finishes, no?
T 1459945427 18<kefin_18>	jaysonsantos: That depends, if both read it's fine, but there can only be one writer
T 1459945647 18<kefin_18>	Trying to find some resources, I'm sure I've seen it before in Rust...
T 1459945648 18<jaysonsantos18>	kefin_: Mutex is going to lock only for writes?
T 1459945825 18<kefin_18>	jaysonsantos: No not afaik,...
T 1459945851 18<kefin_18>	jaysonsantos: I think I found it: https://doc.rust-lang.org/std/sync/struct.RwLock.html
T 1459945922 18<jaysonsantos18>	I managed to make it work moving let data = data.clone(); outside the thread, but I don't know if it is right
T 1459945954 18<kefin_18>	Are you cloning the Vec itself?
T 1459945969 18<kefin_18>	Also check out RwLock, it's exactly what you asked for :)
T 1459946140 18<jaysonsantos18>	this is my last change http://is.gd/hMmbih
T 1459946160 18<jaysonsantos18>	but is it really parallel? Or the clone outside is making some sort of lock?
T 1459946189 18<kefin_18>	jaysonsantos: cloning an arc just copies a few bytes in memory
T 1459946242 18<kefin_18>	jaysonsantos: I also suspect that data is immutable, thus allowing concurrent reads
T 1459946246 18<kimundi18>	jaysonsantos: cloning the Arc outside the thread is the correct way to do this
T 1459946266 18<jaysonsantos18>	thanks guys
T 1459946279 18<kimundi18>	since you want to transfer ownership of the cloned handle into the thread, not of the original one
T 1459946342 18<jaysonsantos18>	my first try was doing the clone inside but the compiler was complaining that data was already moved
T 1459946493 18<leaper18>	How can I update nightly in Rustup? The usual command gives an error since yesterday.
T 1459946615 18<llandersll18>	Can anyone explain this to me: http://is.gd/apLEBd if I remove the lifetime on the TriangleMeshHandle return specifier on line 19 then the borrow checker tells me off. I kinda get that I *should* add the lifetime here, but I don't really understand why
T 1459946843 18<panicbit18>	LambdaComplex: That is 0.006 with --release
T 1459948892 18<sprog18>	I'm confused about when I need to use `extern crate blah;` in sub modules. It seems that if they are already declared in a parent module I don't need to redeclare the dependency, but sometimes I do.
T 1459948911 18<bluss18>	right, that's not needed
T 1459948934 18<sprog18>	But sometimes it seems to be.
T 1459948938 18<bluss18>	usually best to keep all the extern crate lines in the top level of your crate
T 1459948954 18<bluss18>	sprog: depends on where you want 'blah` to be in the namespace
T 1459948968 18<bluss18>	an absolute path starts with :: if you use it in an expression
T 1459948983 18<bluss18>	or you can just put `use blah` at the top of the local module
T 1459948995 18<bluss18>	to make the absolute path ::blah be available as just blah
T 1459949062 18<sprog18>	OK, so the rule is: `extern crate foo;` brings the module `foo` into the current path.
T 1459949080 18<bluss18>	yes
T 1459949092 18<sprog18>	so if I do that in a sub module, a parent module could access it by `submod::foo`.
T 1459949093 18<bluss18>	and `use` uses absolute paths (from the crate root)
T 1459949098 18<bluss18>	expressions use relative paths
T 1459949155 18<sprog18>	What is the preferred style: bundle all `extern crate` calls into the root module and use `use`, or redeclare `extern` calls.
T 1459949158 18<bluss18>	here's an example http://is.gd/RBghhn
T 1459949168 18<bluss18>	put all extern crate in the root
T 1459949176 18<bluss18>	in particular, don't use more than one extern crate IMO
T 1459949201 18<sprog18>	OK, thanks for the help bluss!
T 1459950588 18<blashyrk18>	since there is no inheritance in rust, how can I make a container that contains different kind of stuff? I could cram all sorts of different functionality into a single struct but that would be quite ugly I suppose
T 1459950671 18<kefin_18>	blashyrk, I think there's dynamic dispatch by using references to an Impl
T 1459950686 18<kefin_18>	So either Box<impl_name> or &impl_name inside a collection should work
T 1459951442 18<tchosky18>	I have a question
T 1459951496 18<bluss18>	another strategy for handling multiple different types is to use an enum
T 1459951775 18<tchosky18>	can you read me>?
T 1459951894 18<bluss18>	tchosky: sure, ask away
T 1459952467 18<blashyrk18>	bluss: so a container of enums would work? and I could assign structs to different enum types as params? 
T 1459952475 18<blashyrk18>	that sounds like an awesome solution if it's possible
T 1459952509 18<bluss18>	enums are the closed-set-of-possibilities solution
T 1459952521 18<bluss18>	and a trait object for the open set of possibilities solution
T 1459952552 18<blashyrk18>	this is very closed-set-of-possibilities -like
T 1459952563 18<blashyrk18>	but it never occured to me that I can use something like 
T 1459952573 18<blashyrk18>	some_vec: Vec<EnumType>
T 1459952591 18<blashyrk18>	and have EnumType::SomeOption(s: SomeStruct)
T 1459952613 18<bluss18>	that's why I mentioned it, both approaches exist
T 1459952625 18<bluss18>	both use some degree of boilerplate
T 1459952634 18<bluss18>	code
T 1459952639 18<blashyrk18>	I keep thinking of enums as C-like loosely coupled "stupid" enums, so thanks for reminding me that Rust enums are awesome :D
T 1459952653 18<bluss18>	yeah
T 1459952663 18<bluss18>	we should have that on a banner when you enter
T 1459952680 18<bluss18>	1) Rust enums are awesome and 2) Learn `match' use `match'
T 1459952687 18<blashyrk18>	haha aboslutely
T 1459954384 18<LambdaComplex18>	panicbit: What is it without --release? D:
T 1459954707 18<LambdaComplex18>	Hey, cargo decided it will work on my laptop again. Neat.
T 1459954871 18<panicbit18>	LambdaComplex: Roughly th same IIRC^^, I'll check it again
T 1459954895 18<LambdaComplex18>	panicbit: Alright :D
T 1459954896 18<panicbit18>	LambdaComplex: I suppose some of the overhead comes from translating some XCB stuff
T 1459954905 18<LambdaComplex18>	panicbit: Yeah, that certainly makes sense
T 1459954955 18<LambdaComplex18>	panicbit: I don't suppose you feel like testing my latest swm-rust release to help me troubleshoot?
T 1459954997 18<panicbit18>	LambdaComplex: Hm, I was going to translate it to get more stuff into lax
T 1459955027 18<LambdaComplex18>	panicbit: Translate what?
T 1459955040 18<panicbit18>	LambdaComplex: The swm-rust to the lax abstarction
T 1459955054 18<panicbit18>	abstraction*
T 1459955059 18<LambdaComplex18>	panicbit: Ah, gotcha
T 1459955070 18<LambdaComplex18>	panicbit: Why don't we get the XCB version working 100% first though?
T 1459955076 18<panicbit18>	Good idea
T 1459955088 18<LambdaComplex18>	Like I said last night, I have all the code "done"
T 1459955092 18<LambdaComplex18>	It just doesn't work right >.>
T 1459955150 18<panicbit18>	LambdaComplex: I don't see much of a difference between debug and release builds in clap lsw
T 1459955164 18<panicbit18>	(speedwise
T 1459955165 18<panicbit18>	)
T 1459955192 18<LambdaComplex18>	Works for me!
T 1459955198 18<LambdaComplex18>	Shall I go accept that PR?
T 1459955208 18<panicbit18>	Well, yeah :D
T 1459955224 18<panicbit18>	It's definitely an improvement over docopt
T 1459955230 18<panicbit18>	It even looks cleaner
T 1459955289 18<LambdaComplex18>	Yeah, especially since you don't have to put the entire output of --help right in the main file
T 1459955490 18<LambdaComplex18>	panicbit: So are you gonna check swm out?
T 1459955556 18<panicbit18>	Yeah I will
T 1459955574 18<panicbit18>	Right after lunch
T 1459955775 18<blashyrk18>	why do I get "cannot move out of borrowed content" here? http://is.gd/uIZwgo
T 1459955851 18<blashyrk18>	and why does this work, instead? http://is.gd/NaUSgx
T 1459955914 18<panicbit18>	blashyrk: In the first example you are moving _something out of the e
T 1459955937 18<panicbit18>	blashyrk: In the second example you only take a reference to _something, so everything is fine
T 1459956086 18<panicbit18>	When you bind to something in a pattern, you move the whole thing
T 1459956093 18<blashyrk18>	so capturing something in a closure moves its ownership to the closure by default? or does the pattern matching part do that here?
T 1459956096 18<panicbit18>	Unless the value you bind to is copy
T 1459956104 18<panicbit18>	Or you only take a reference to it using `ref`
T 1459956104 18<blashyrk18>	ooooh
T 1459956146 18<panicbit18>	So you moved e/_something into the match arm
T 1459956267 18<panicbit18>	blashyrk: Heh, I just realized that my fancy macro would allow you to write this instead: `.filter(|e| e.maybe_into::<A>().is_some() })`
T 1459956269 18<blashyrk18>	didn't realize matching would do that
T 1459956270 18<panicbit18>	<3
T 1459956313 18<panicbit18>	(er, there's a rogue '}' there)
T 1459956325 18<blashyrk18>	is that a part of some crate?
T 1459956331 18<panicbit18>	blashyrk: Not yet
T 1459956332 18<blashyrk18>	never seen maybe_into before :D
T 1459956374 18<panicbit18>	blashyrk: I currently have an open PR that adds MaybeInto/MaybeFrom to the conv crate
T 1459956384 18<panicbit18>	blashyrk: Also, maybe_into is only halve of the story
T 1459956416 18<panicbit18>	blashyrk: `A` would be it's own type here that matches the structure of TestEnum::A
T 1459956429 18<panicbit18>	(This would be generated by the macro)
T 1459956470 18<blashyrk18>	and that would work with enum variants that have data associate with them as well?
T 1459956503 18<panicbit18>	Yeah!
T 1459956524 18<blashyrk18>	I'm not at all familiar to Rust on the level that would make me comprehend how :)
T 1459956531 18<panicbit18>	macro magic :)
T 1459956555 18<panicbit18>	I'm just parsing your enum definition and generate some neat additional code ;)
T 1459956602 18<archer88418>	Say I have an extern crate that has a macro, which I declare as `#[macro_use] extern crate thign;` How do I then get to use that macro in another module?
T 1459956634 18<panicbit18>	archer884: You should be able to just use it
T 1459956667 18<panicbit18>	It should be available to your whole crate
T 1459956782 18<panicbit18>	blashyrk: Ah, it wouldn't actually work...
T 1459956830 18<panicbit18>	blashyrk: Because the MaybeInto/MaybeFrom stuff requires moving the enum, but you can't do that in .filter
T 1459956831 18<blashyrk18>	why not
T 1459956869 18<blashyrk18>	I was just about to ask whether there was a way to compactify the code I pasted there
T 1459956878 18<blashyrk18>	using a match inside a filter closure seems overly... verbose
T 1459956883 18<panicbit18>	Yeah it is
T 1459956904 18<panicbit18>	blashyrk: You could also if-let
T 1459956906 18<blashyrk18>	also, I'm not sure "compactify" was a word before I used it just then, but I like it xD
T 1459956911 18<panicbit18>	But it would look similarly verbose
T 1459956936 18<panicbit18>	I have an idea though
T 1459956987 18<archer88418>	Darn. Ok, looking deeper, it seems to be that I don't have unstable features turned on. How do you do that? oO
T 1459956989 18<panicbit18>	blashyrk: http://is.gd/gtn6lq
T 1459957006 18<mbrubeck18>	archer884: unstable features are only available in Rust nightly builds
T 1459957021 18<archer88418>	Yeah, this is the latest nightly... and it's not that kind of feature.
T 1459957044 18<archer88418>	This guy has his sample `main` marked with `#[cfg(feature = "unstable")]`, which I've never seen before. 
T 1459957047 18<mbrubeck18>	archer884: Ah, are you using a dependency that has an feature named "unstable"?
T 1459957052 18<archer88418>	Probably.
T 1459957054 18<archer88418>	:)
T 1459957137 18<mbrubeck18>	archer884: In your Cargo.toml dependencies section, you can do `crate_name = { version = "0.0.1", features = ["unstable"] }`
T 1459957137 18<archer88418>	I figure this means I need to do something in my toml, but I'm not familiar with that process.
T 1459957137 18<archer88418>	Thank you!
T 1459957137 18<mbrubeck18>	For more details see http://doc.crates.io/manifest.html#the-features-section
T 1459957198 18<blashyrk18>	panicbit: this looks much nicer, thanks!
T 1459957227 18<blashyrk18>	if a bit cryptic 
T 1459957238 18<blashyrk18>	at least to my newbie eyes
T 1459957247 18<panicbit18>	blashyrk: You could have also used if-let to return true/false from the filter, but this is still simpler. It comes with the visual cost of another indentation though :)
T 1459957270 18<panicbit18>	blashyrk: It is definitily clearer IMO
T 1459957321 18<blashyrk18>	yeah, definitely
T 1459957325 18<mbrubeck18>	blashyrk, panicbit: https://crates.io/crates/matches could be useful here too
T 1459957356 18<panicbit18>	Ah nice
T 1459957388 18<blashyrk18>	mbrubeck: if this could work with enums and I suppose it does, then I could use it to replace enum_set completely! 
T 1459957394 18<mbrubeck18>	.filter(|&e| matches!(*e, TestEnum::A(_))
T 1459957418 18<mbrubeck18>	It just generates the same `match` expression that you had originally
T 1459957459 18<blashyrk18>	I was thinking about using this to "emulate" an enum set. since the one in std::collections isn't stable yet and the enum_set crate has one but it needs coding/decoding each enum to a u32
T 1459957500 18<blashyrk18>	that is, if this "|" or-like thingy would work with enum variants
T 1459957717 18<panicbit18>	blashyrk: Well, you could use the bitwise or (|) to combine your enum values
T 1459957732 18<panicbit18>	blashyrk: But you'd have to define a variant for each permutation
T 1459957766 18<panicbit18>	e.g. for an enum with variants A and B, you'd also have to add a variant AB
T 1459957783 18<panicbit18>	For A,B,C you'd need AB, AC, BC, and ABC
T 1459957794 18<blashyrk18>	yeah, someone told me that before, possibly you :)
T 1459957802 18<panicbit18>	Nope I didn't =D
T 1459957809 18<mbrubeck18>	You can use `TestEnum::A(..) | TestEnum::B(..)` syntax in a `match` expression or `matches!` macro, though.
T 1459957812 18<panicbit18>	Ok, so you know
T 1459957821 18<blashyrk18>	that's why I opted for using the enum_set crate instead
T 1459957839 18<blashyrk18>	mbrubeck: I know, but what I needed was to define "
T 1459957857 18<blashyrk18>	allowed enum variants and store that as a struct field
T 1459957883 18<blashyrk18>	and an enum_set works fine for that, the only pesky thing is that coding from/to u32
T 1459957913 18<blashyrk18>	I don't know how the std implementation of EnumSet will work once it's stable, I'm hoping that sort of thing will be done automatically behind the scenes
T 1459958731 18<panicbit18>	LambdaComplex: What exactly doesn't work?
T 1460058167 19*	Now talking on 22#rust-beginners
T 1460058167 22*	Topic for 22#rust-beginners is: Beginner's Rust discussion, unlogged. Ask away! |  Playground  https://play.rust-lang.org | Forum  https://users.rust-lang.org | Conduct   https://www.rust-lang.org/conduct.html 
T 1460058167 22*	Topic for 22#rust-beginners set by 26steveklabnik!root@moz-fft.uo8.55.45.IP (24Wed Feb 17 21:12:56 2016)
T 1460060338 18<leaper18>	Hi, is there a guide somewhere that sets put how to install Rust (under Rustup) and MSYS2, on Windows 7, using the GNU version of the Rust distributable, so that it all just works?
T 1460060441 18<leaper18>	I can install one or the other, but c/c++ libraries I compile and install under MSYS2 are not available to Rust.
T 1460060460 18<leaper18>	And Rust won't run in MSYS2.
T 1460060484 18<peschkaj18>	https://github.com/rust-lang/rust#mingw
T 1460060589 18<leaper18>	Thanks, peschkaj I'll give that a whirl: compiling Rust from within MSYS2. Bye.
T 1460060611 18<peschkaj18>	leaper: IIRC, unless you go to great lengths to make MSYS aware of things outside of the MSYS install, it's not going to see them. Best of luck!
T 1460060628 18<leaper18>	OK thanks.
T 1460060688 18<peschkaj18>	Once you have an msys2 you're happy with, you can probably use the rustup instructions for rustup.sh
T 1460061166 18<blashyrk18>	is there some sort of built in mechanism to parse hex strings to numbers? str::parse() doesn't seem to do that
T 1460061201 18<blashyrk18>	oh, nvm, there's a crate for that
T 1460061211 18<bluss18>	blashyrk: integers have methods for it
T 1460061223 18<bluss18>	playbot: u32::from_str_radix("ffe", 16)
T 1460061224 -18playbot/22#rust-beginners-	Ok(4094)
T 1460061246 18<bluss18>	playbot: u32::from_str_radix("F", 16)
T 1460061247 -18playbot/22#rust-beginners-	Ok(15)
T 1460061251 18<bluss18>	ok
T 1460061265 18<blashyrk18>	hmmm what about 0x... notation?
T 1460061279 18<bluss18>	probably not supported. You can slice it away
T 1460061283 18<bluss18>	playbot: u32::from_str_radix("0xF", 16)
T 1460061285 -18playbot/22#rust-beginners-	Err(ParseIntError { kind: InvalidDigit })
T 1460061292 18<blashyrk18>	guess so, thanks!
T 1460061655 18<mbrubeck18>	You can use `.trim_left_matches("0x")` to trim off an optional 0x prefix
T 1460061948 18<chainsaw1018>	How can I convert a number (specifically u32 in this case) to a string? I'm trying `i.to_string().chars().collect::<String>()`, and I'm getting various type errors. (Relevant point: I'm trying to concatenate two of them and save them in a variable)
T 1460061979 18<chainsaw1018>	Wait nevermind, just reread that, sorry :0
T 1460061984 18<blashyrk18>	mbrubeck: great, thannks!
T 1460061985 18<ivan18>	playbot: format!("{}", 3u32)
T 1460061986 -18playbot/22#rust-beginners-	"3"
T 1460061997 18<mbrubeck18>	playbot: 3.to_string()
T 1460061999 -18playbot/22#rust-beginners-	"3"
T 1460062158 18<chainsaw1018>	Thanks! Slightly better question: I'm trying to convert two numbers to string, then concatenate them. I'm trying `let forward = i.to_string() + j.to_string();`, and the type checker doesn't like that for some reason. Any idea why?
T 1460062205 18<blashyrk18>	what's the most idiomatic way to take some values upfront from the iterator, then skip iterating upon those values?
T 1460062238 18<mbrubeck18>	chainsaw10: I think String only implements Add<&str>, so you need to take a reference to the second one: `i.to_string() + &j.to_string()`
T 1460062250 18<mbrubeck18>	chainsaw10: format!("{}{}", i, j) is also a common way to do this
T 1460062362 18<chainsaw1018>	mbrubeck: Thanks! That fixed the compile error. Which way is more readable to someone that actually knows Rust?
T 1460062383 18<mbrubeck18>	I have no strong preference between the two...
T 1460062439 22*	26ChanServ gives channel operator status to 18niconii
T 1460062470 18<chainsaw1018>	mbrubeck: Okay, thanks again.
T 1460062991 18<ijks18>	Is there a method/function to flatten a Vec<Vec<T>> -> Vec<T>? I can't seem to find one.
T 1460063118 18<ijks18>	I suppose I could write it as a fold using append(), would that be idiomatic?
T 1460063141 18<bluss18>	ijks: yes, methods .concat() or .join(sep)
T 1460063143 18<kefin_18>	ijks: That seems like an unneeded overhead, why not create an iterator instead that wraps linearly?
T 1460063159 18<Xion18>	I thought join() only works on strings.
T 1460063162 18<bluss18>	ijks: although these methods are based on copying all T
T 1460063169 18<bluss18>	Xion: it works on slices too
T 1460063193 18<Xion18>	If you want a vector output then you kind need to copy the elements.
T 1460063200 18<bluss18>	ijks: using flat_map will be easy at least, if you want to move all the elements
T 1460063207 18<Xion18>	Otherwise you probably have to write your own iterator.
T 1460063210 18<bluss18>	Xion: you don't need a rust level copy
T 1460063218 18<kefin_18>	Xion: can't he move the elements out and then move them into the new vector?
T 1460063236 18<mbrubeck18>	I was going to say `vec.into_iter().flat_map(|v| v).collect();` but `vec.concat()` is better.
T 1460063253 18<bluss18>	they do different things
T 1460063258 18<Xion18>	Ahem.
T 1460063260 18<bluss18>	so pick the one you need :)
T 1460063271 18<Xion18>	Call it however you want but these contiguous blocks of memory you'll be merging.
T 1460063315 18<bluss18>	Xion: we just need to keep straight when we talk of copying in rust semantics or if copying memory
T 1460063360 18<ijks18>	bluss: I'm silly, just found out I was already using concat.
T 1460063380 18<moriarty18>	is there a better way to convert a &[u8] to [u16; N] other than repeatedly calling byteorder::ReadBytesExt::read_u16? can I make its reader yield an array directly?
T 1460063422 18<Xion18>	bluss: What's "copying in Rust semantics" though? My intuition is "moving of Copy objects" which I'm inclined to simplify to just "moving".
T 1460063459 18<bluss18>	Clone is the generalization of copying values
T 1460063492 18<Xion18>	Right, but Clone is explicit and can be called cloning :)
T 1460063529 18<bluss18>	it's explicit in a way
T 1460063598 18<snirk18>	Any kind of complex data could impl Clone and be cloned with .clone(), but types implementing Copy should be assumed to be light enough or special to be implicitly copied around
T 1460063652 18<bluss18>	I don't agree that they can be assumed to be light as in just a few bytes
T 1460063753 18<Xion18>	Nothing prevents you from implementing Copy on a huge type. Then again, the feet are always a convenient target to shoot at :)
T 1460063780 18<snirk18>	That's not shooting at your feet, that's just putting on concrete galoshes
T 1460063805 18<snirk18>	But yeah, if you need to call .clone() on something all the time, you've probably got borrowing issues
T 1460063806 18<ubsan_18>	I don't agree, implementing Copy is fine on large types
T 1460063812 18<ijks18>	snirk: and jumping into a lake?
T 1460063823 18<snirk18>	Just make sure you add some ampersands around and you'll be fine :P
T 1460063827 18<Xion18>	snirk :)
T 1460063829 18<ubsan_18>	if you need to memcpy, you need to memcpy
T 1460063839 18<ubsan_18>	and you should be using references otherwise
T 1460064696 18<chainsaw1018>	Is there an exponent operator or function in rust? Couldn't find it with a quick Google.
T 1460064753 18<Xion18>	There are pow?() methods
T 1460064767 18<Xion18>	playbot: 42.pow(2)
T 1460064767 -18playbot/22#rust-beginners-	<anon>:9:12: 9:18 error: no method named `pow` found for type `_` in the current scope
T 1460064768 -18playbot/22#rust-beginners-	<anon>:9         42.pow(2)
T 1460064768 -18playbot/22#rust-beginners-	output truncated; full output at: http://bit.ly/22gamsX
T 1460064772 18<Xion18>	Or maybe not.
T 1460064800 18<Xion18>	playbot: (42 as i32).pow(2)
T 1460064801 -18playbot/22#rust-beginners-	1764
T 1460064824 18<huon18>	playbot: 42_i32.pow(2) // (can use suffixes as well as/instead of casts)
T 1460064825 -18playbot/22#rust-beginners-	1764
T 1460064832 18<chainsaw1018>	Xion: Thanks!
T 1460064856 18<Xion18>	playbot: 42_usize_i32.pow(2) // am I taking this too far?
T 1460064857 -18playbot/22#rust-beginners-	<anon>:9:9: 9:21 error: invalid suffix `usize_i32` for numeric literal
T 1460064857 -18playbot/22#rust-beginners-	<anon>:9         42_usize_i32.pow(2) // am I taking this too far?
T 1460064857 -18playbot/22#rust-beginners-	output truncated; full output at: http://bit.ly/1VBPf41
T 1460064860 18<Xion18>	Appears so.
T 1460064923 18<chainsaw1018>	Is there a difference between 42i32 or 42_i32? I've been using 42i32, is something else more idiomatic?
T 1460064951 18<bluss18>	chainsaw10: it's just a style choice
T 1460064972 18<bstrie18>	chainsaw10: typically I only see underscores used to separate digits when there are a lot of them, like 1_000_000
T 1460065005 18<bstrie18>	chainsaw10: also I typically avoid `let x = 42i32` when I can, in favor of `let x: i32 = 42`. but this is up to you
T 1460065068 18<chainsaw1018>	bstrie: thanks. I assumed `let x = 42i32` was more idiomatic for some reason. I guess I'll start doing `let x: i32 = 42` instead
T 1460065089 18<ijks18>	playbot: let x = 42 as i32;
T 1460065090 -18playbot/22#rust-beginners-	()
T 1460065096 18<bstrie18>	chainsaw10: it's subjective, that's just my personal preference :)
T 1460065097 18<ijks18>	playbot: let x = 42 as i32; x
T 1460065098 -18playbot/22#rust-beginners-	42
T 1460065109 18<ijks18>	I suppose that works as well
T 1460065111 18<blashyrk18>	is there a concept of "returning ownership"? say I want to pass something into a function, and the function should decide whether to retain or "return" ownership to the caller?
T 1460065116 18<bstrie18>	ijks: I rarely see `as` being used like that, I'd prefer either of the two prior options
T 1460065128 18<ijks18>	bstrie: agreed, was just wondering if it was possible.
T 1460065132 18<panicbit18>	blashyrk: Sounds's like Cow
T 1460065150 18<bstrie18>	blashyrk: if you know that you want to return ownership, then it's idiomatic to have `fn blah(x: Foo) -> Foo`
T 1460065157 18<bstrie18>	and just give the parameter back when you're done
T 1460065161 18<chainsaw1018>	ijks: bstrie: bluss: Thanks! I ought to give the Rust style guide a read :)
T 1460065167 18<mbrubeck18>	blashyrk: Some functions have signatures like `f(x: T) -> Result<U, T>` so they can give back ownership in the error case
T 1460065200 18<mbrubeck18>	blashyrk: For example http://doc.rust-lang.org/std/sync/mpsc/struct.Sender.html#method.send
T 1460065202 18<ijks18>	bstrie: when is that form preferred vs a `&mut T`?
T 1460065250 18<ijks18>	bstrie: seems like they both give the function temporary access to a value, though the owned version does a move and all that, I think.
T 1460065257 18<bstrie18>	chainsaw10: personally, I only use the `42i32` form when the integer is part of a larger expression, because in that case it might be a pain to type out the entire type on the left-hand-side. so something like `let x = &[42u8, 43, 44]` might be preferable to `let x: &[u8] = [42, 43, 44]`
T 1460065262 18<blashyrk18>	the problem is, I want to return something completely different, and implicitly return ownership if the object is not used. my function has this signature fn func(something: Something) -> Option<SomethingElse> 
T 1460065294 18<blashyrk18>	so I guess I'd have to rewrite it so that it becomes: fn func(something: Something) -> Result<Option<SomethingElse>, Something> and check the result ? 
T 1460065315 18<blashyrk18>	or simply  fn func(something: Something) -> Result<SomethingElse, Something>
T 1460065317 18<chainsaw1018>	bstrie: yeah, that makes sense. (And for me, at the moment, I usually *can't* type out the entire type on the left, if it's complicated ;)
T 1460065320 18<ijks18>	blashyrk: does the function need to own the `Something` to produce the `SomethingElse`?
T 1460065326 18<bstrie18>	blashyrk: check out https://doc.rust-lang.org/std/borrow/enum.Cow.html
T 1460065350 18<blashyrk18>	ijks: the function transfers ownership of something into SomethingElse, if that SomethingElse can be constructed
T 1460065366 18<blashyrk18>	bstrie: thanks, I'll read that now
T 1460065375 18<ijks18>	blashyrk: ah, I see.
T 1460065438 18<mbrubeck18>	blashyrk: Yes, Result<SomethingElse, Something> should work for your use case
T 1460065617 18<panicbit18>	Looks like the same pattern that Rc::try_unwrap uses http://doc.rust-lang.org/nightly/std/rc/struct.Rc.html#method.try_unwrap
T 1460065719 FiSHLiM plugin unloaded
T 1460065719 Python interface unloaded
